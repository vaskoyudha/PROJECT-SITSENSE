<!doctype html>
<html lang="id">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Monitoring Tubuh</title>
  <link href="https://cdn.jsdelivr.net/npm/daisyui@4.12.10/dist/full.min.css" rel="stylesheet" />
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Ambil config/app dari parent window (iframe) jika ada -->
  <script>
    (function () {
      try {
        // 1) Salin konfigurasi eksplisit jika tersedia
        if (window.parent && window.parent.FIREBASE_CONFIG && !window.FIREBASE_CONFIG) {
          window.FIREBASE_CONFIG = window.parent.FIREBASE_CONFIG;
        }
        // 2) Jika tidak ada, tetapi parent sudah inisialisasi firebase app, ambil options-nya
        if (!window.FIREBASE_CONFIG && window.parent && window.parent.firebase && window.parent.firebase.apps && window.parent.firebase.apps.length > 0) {
          try {
            var parentApp = window.parent.firebase.app();
            var opts = parentApp && parentApp.options;
            if (opts) {
              // Pastikan databaseURL ikut terbawa
              window.FIREBASE_CONFIG = {
                apiKey: opts.apiKey,
                authDomain: opts.authDomain,
                projectId: opts.projectId,
                appId: opts.appId,
                messagingSenderId: opts.messagingSenderId,
                storageBucket: opts.storageBucket,
                databaseURL: opts.databaseURL || (window.parent.FIREBASE_CONFIG && window.parent.FIREBASE_CONFIG.databaseURL) || undefined
              };
            }
          } catch (e) { }
        }
        // 3) Propagasi endpoint backend opsional
        if (window.parent && typeof window.parent.BACKEND_ENDPOINT !== 'undefined' && typeof window.BACKEND_ENDPOINT === 'undefined') {
          window.BACKEND_ENDPOINT = window.parent.BACKEND_ENDPOINT;
        }
      } catch (e) { }
    })();
  </script>
  <!-- Default Firebase config (fallback) -->
  <script>
    (function () {
      if (!window.FIREBASE_CONFIG) {
        window.FIREBASE_CONFIG = {
          apiKey: "AIzaSyCHpITmPUoKIb2niuh0G4vhJJJ0vBM2ijE",
          authDomain: "esp32kursi-pintar.firebaseapp.com",
          databaseURL: "https://esp32kursi-pintar-default-rtdb.firebaseio.com",
          projectId: "esp32kursi-pintar",
          storageBucket: "esp32kursi-pintar.appspot.com",
          messagingSenderId: "265798521874",
          appId: "1:265798521874:web:6097e5ae6ccf8ad683b4cb"
        };
      }
    })();
  </script>
  <!-- Firebase SDK (compat for simplicity in inline JSX) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
  <!-- Jika parent sudah punya instance firebase, gunakan langsung -->
  <script>
    (function () {
      try {
        if (window.parent && window.parent.firebase && window.parent.firebase.apps && window.parent.firebase.apps.length > 0) {
          // Reuse instance parent agar tidak perlu re-init
          window.firebase = window.parent.firebase;
          // Jika belum ada FIREBASE_CONFIG, set dari app yang aktif
          if (!window.FIREBASE_CONFIG) {
            try {
              var app = window.firebase.app();
              var opts = app && app.options;
              if (opts) {
                window.FIREBASE_CONFIG = {
                  apiKey: opts.apiKey,
                  authDomain: opts.authDomain,
                  projectId: opts.projectId,
                  appId: opts.appId,
                  messagingSenderId: opts.messagingSenderId,
                  storageBucket: opts.storageBucket,
                  databaseURL: opts.databaseURL
                };
              }
            } catch (e) { }
          }
        }
      } catch (e) { }
    })();
  </script>
  <style>
    html,
    body {
      background: transparent;
    }

    @keyframes float {

      0%,
      100% {
        transform: translateY(0px) translateX(0px);
      }

      50% {
        transform: translateY(-20px) translateX(10px);
      }
    }

    @keyframes scan {
      0% {
        top: -2px;
      }

      100% {
        top: 100%;
      }
    }

    @keyframes scan-vertical {
      0% {
        transform: translateY(-100%);
      }

      100% {
        transform: translateY(100%);
      }
    }

    @keyframes sonar {
      0% {
        width: 32px;
        height: 32px;
        opacity: 1;
      }

      100% {
        width: 200px;
        height: 200px;
        opacity: 0;
      }
    }

    @keyframes shimmer {
      0% {
        transform: translateX(-100%);
      }

      100% {
        transform: translateX(100%);
      }
    }

    @keyframes blob {

      0%,
      100% {
        transform: translate(0, 0) scale(1);
      }

      33% {
        transform: translate(30px, -50px) scale(1.1);
      }

      66% {
        transform: translate(-20px, 20px) scale(0.9);
      }
    }

    @keyframes gradient-x {

      0%,
      100% {
        background-position: 0% 50%;
      }

      50% {
        background-position: 100% 50%;
      }
    }

    @keyframes glitch {

      0%,
      100% {
        transform: translate(0);
      }

      20% {
        transform: translate(-2px, 2px);
      }

      40% {
        transform: translate(-2px, -2px);
      }

      60% {
        transform: translate(2px, 2px);
      }

      80% {
        transform: translate(2px, -2px);
      }
    }

    .animate-scan {
      animation: scan 3s linear infinite;
    }

    .animate-scan-vertical {
      animation: scan-vertical 4s ease-in-out infinite;
    }

    .animate-sonar {
      animation: sonar 2.4s cubic-bezier(0, 0, 0.2, 1) infinite;
    }

    .animate-shimmer {
      animation: shimmer 2s infinite;
    }

    .animate-blob {
      animation: blob 7s infinite;
    }

    .animation-delay-2000 {
      animation-delay: 2s;
    }

    .animation-delay-4000 {
      animation-delay: 4s;
    }

    .animate-gradient-x {
      background-size: 200% 200%;
      animation: gradient-x 3s ease infinite;
    }

    .animate-glitch {
      animation: glitch 0.3s infinite;
    }
  </style>
  <!-- React via CDN + Babel for JSX -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>

<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect } = React;

    // Icon offline renderer using local SVG + CSS mask
    // Supports solid colors via text-* (currentColor) OR gradients via bg-gradient-* + from-*/to-*
    const IconStatic = ({ name, className = '', style }) => {
      const map = {
        'activity': '../assets/icons/activity.svg',
        'radio': '../assets/icons/radio.svg',
        'wifi': '../assets/icons/wifi.svg',
        'zap': '../assets/icons/zap.svg',
        'trending-up': '../assets/icons/trending-up.svg',
        'bar-chart-3': '../assets/icons/trending-up.svg', // fallback if missing
        'alert-circle': '../assets/icons/loader-circle.svg', // fallback if missing
        'loader-circle': '../assets/icons/loader-circle.svg'
      };
      const src = map[name] || map['loader-circle'];
      const usesGradient = (className || '').includes('bg-gradient') || (className || '').includes('from-');
      const maskStyles = {
        WebkitMaskImage: `url("${src}")`,
        WebkitMaskRepeat: 'no-repeat',
        WebkitMaskPosition: 'center',
        WebkitMaskSize: 'contain',
        maskImage: `url("${src}")`,
        maskRepeat: 'no-repeat',
        maskPosition: 'center',
        maskSize: 'contain',
        // If no gradient classes provided, fall back to currentColor (text-*)
        ...(usesGradient ? {} : { backgroundColor: 'currentColor' }),
        display: 'inline-block'
      };
      return <span aria-hidden="true" className={className} style={{ ...maskStyles, ...style }} />;
    };

    const UltrasonicMonitor = () => {
      const [neckDistance, setNeckDistance] = useState(0);
      const [backDistance, setBackDistance] = useState(0);
      const [particles, setParticles] = useState([]);
      const [signalStrength, setSignalStrength] = useState(100);
      const [neckHistory, setNeckHistory] = useState(Array(30).fill(0));
      const [backHistory, setBackHistory] = useState(Array(30).fill(0));
      const [useSimulation, setUseSimulation] = useState(false);
      // Debug console state
      const search = (typeof window !== 'undefined' && (window.location?.search || '')) || '';
      const parentSearch = (typeof window !== 'undefined' && window.parent && window.parent.location && window.parent.location.search) || '';
      const debugEnabled = /[?&]debug=1\b/.test(search) || /[?&]debug=1\b/.test(parentSearch);
      const [debugVisible, setDebugVisible] = useState(debugEnabled);
      const [events, setEvents] = useState([]);
      const logEvent = (evt) => {
        try {
          const withTs = { ts: new Date().toISOString(), ...evt };
          // Console output
          console.debug('[Ultrasonic][RX]', withTs);
          // UI store (cap to 60)
          setEvents(prev => {
            const next = [...prev.slice(-59), withTs];
            return next;
          });
        } catch (e) { }
      };
      const backendUrl = window.BACKEND_ENDPOINT || null;

      useEffect(() => {
        const newParticles = Array.from({ length: 20 }, (_, i) => ({
          id: i,
          x: Math.random() * 100,
          y: Math.random() * 100,
          size: Math.random() * 4 + 2,
          duration: Math.random() * 3 + 2,
          delay: Math.random() * 2
        }));
        setParticles(newParticles);

        if (!useSimulation) return;
        const interval = setInterval(() => {
          const newNeckDist = Math.max(5, Math.min(50, neckDistance + (Math.random() - 0.5) * 3));
          const newBackDist = Math.max(5, Math.min(50, backDistance + (Math.random() - 0.5) * 3));
          setNeckDistance(newNeckDist);
          setBackDistance(newBackDist);
          setSignalStrength(Math.floor(Math.random() * 20) + 80);
          setNeckHistory(prev => [...prev.slice(1), newNeckDist]);
          setBackHistory(prev => [...prev.slice(1), newBackDist]);
        }, 100);
        return () => clearInterval(interval);
      }, [neckDistance, backDistance, useSimulation]);

      // Initialize Firebase and attach realtime listeners (compat API)
      useEffect(() => {
        try {
          const cfg = window.FIREBASE_CONFIG;
          if (!cfg) {
            console.warn('[Monitor] FIREBASE_CONFIG not found; running simulation.');
            return;
          }
          if (cfg && !(window.firebase?.apps?.length)) {
            window.firebase.initializeApp(cfg);
          }
          const db = window.firebase?.database?.();
          if (!db) {
            console.warn('[Monitor] firebase.database() unavailable; running simulation.');
            return;
          }

          const refs = [];
          let lastNeck = null, lastBack = null;
          let seenData = false;

          // Fungsi normalisasi untuk digunakan di listener
          const normalizeValue = (value, sensorType) => {
            if (!Number.isFinite(value) || value <= 0) return null;
            if (value > 50) {
              const div10 = value / 10;
              const div100 = value / 100;
              if (sensorType === 'back') {
                if (div10 >= 3 && div10 <= 25) return div10;
                if (div100 >= 3 && div100 <= 25) return div100;
              } else {
                if (div10 >= 15 && div10 <= 40) return div10;
                if (div100 >= 15 && div100 <= 40) return div100;
              }
              return null;
            }
            return value;
          };

          const setupListeners = (deviceId) => {
            console.info(`[Monitor] Attaching listeners for device ID: ${deviceId}`);
            const neckPath = `devices/${deviceId}/live/ultrasonic/leher_cm`;
            const backPath = `devices/${deviceId}/live/ultrasonic/punggung_cm`;

            const attach = (path, onValueCb) => {
              const r = db.ref(path);
              const handler = r.on('value', onValueCb, (err) => console.error('[Monitor] listener error', path, err));
              refs.push({ r, handler });
            };

            attach(neckPath, (snap) => {
              const v = parseFloat(snap.val());
              if (!Number.isNaN(v) && v !== lastNeck) {
                lastNeck = v;
                // Normalisasi nilai sebelum disimpan
                const normalized = normalizeValue(v, 'neck');
                const finalValue = (normalized !== null && Number.isFinite(normalized) && normalized > 0) ? normalized : v;
                setNeckDistance(finalValue);
                setNeckHistory(prev => [...prev.slice(1), finalValue]);
                logEvent({ sensor: 'neck', path: neckPath, raw: snap.val(), parsed: v, normalized: finalValue });
                if (!seenData) { seenData = true; setUseSimulation(false); }
              }
            });

            attach(backPath, (snap) => {
              const v = parseFloat(snap.val());
              if (!Number.isNaN(v) && v !== lastBack) {
                lastBack = v;
                // Normalisasi nilai sebelum disimpan
                const normalized = normalizeValue(v, 'back');
                const finalValue = (normalized !== null && Number.isFinite(normalized) && normalized > 0) ? normalized : v;
                setBackDistance(finalValue);
                setBackHistory(prev => [...prev.slice(1), finalValue]);
                logEvent({ sensor: 'back', path: backPath, raw: snap.val(), parsed: v, normalized: finalValue });
                if (!seenData) { seenData = true; setUseSimulation(false); }
              }
            });
          };

          // Find the first device ID and set up listeners
          db.ref('devices').limitToFirst(1).once('value', (snapshot) => {
            if (snapshot.exists()) {
              const devices = snapshot.val();
              const deviceId = Object.keys(devices)[0];
              if (deviceId) {
                setupListeners(deviceId);
              } else {
                console.warn('[Monitor] No device ID found under /devices.');
              }
            } else {
              console.warn('[Monitor] /devices path does not exist in the database.');
            }
          }).catch(err => {
            console.error('[Monitor] Error fetching device ID:', err);
          });

          return () => {
            try {
              refs.forEach(({ r, handler }) => r.off('value', handler));
            } catch (e) { }
          };
        } catch (e) {
          console.error('[Monitor] Firebase init exception:', e);
        }
      }, []);

      // Optional: post updates to backend endpoint when values change
      useEffect(() => {
        if (!backendUrl) return;
        const controller = new AbortController();
        const payload = {
          neckDistance,
          backDistance,
          signalStrength,
          timestamp: Date.now()
        };
        fetch(backendUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
          keepalive: true,
          signal: controller.signal
        }).catch(() => { });
        return () => controller.abort();
      }, [neckDistance, backDistance, signalStrength, backendUrl]);

      // Broadcast values to parent (index.html) to sync "Jarak Ultrasonik" section
      useEffect(() => {
        try {
          // Fungsi untuk normalisasi nilai (sama seperti di app.js)
          const normalizeValue = (value, sensorType) => {
            if (!Number.isFinite(value) || value <= 0) return null;
            if (value > 50) {
              const div10 = value / 10;
              const div100 = value / 100;
              if (sensorType === 'back') {
                if (div10 >= 3 && div10 <= 25) return div10;
                if (div100 >= 3 && div100 <= 25) return div100;
              } else {
                if (div10 >= 15 && div10 <= 40) return div10;
                if (div100 >= 15 && div100 <= 40) return div100;
              }
              return null; // Invalid
            }
            return value;
          };

          // Fungsi status dengan batas baru yang konsisten
          const statusOf = (d, sensorType) => {
            const normalized = normalizeValue(d, sensorType);
            const value = normalized || d;

            // Jika nilai tidak valid atau > 50 cm
            if (!Number.isFinite(value) || value <= 0 || value > 50) {
              return { text: value > 50 ? 'Error Sensor' : 'Menunggu', color: 'red' };
            }

            // Batas sesuai sensor type
            if (sensorType === 'back') {
              // Back: Ideal 5-15, Waspada 3-5 atau 15-25, Berbahaya <3 atau >25
              if (value >= 5 && value <= 15) return { text: 'Aman', color: 'green' };
              if ((value >= 3 && value < 5) || (value > 15 && value <= 25)) return { text: 'Waspada', color: 'yellow' };
              return { text: 'Berbahaya', color: 'red' };
            } else {
              // Neck: Ideal 20-30, Waspada 15-20 atau 30-40, Berbahaya <15 atau >40
              if (value >= 20 && value <= 30) return { text: 'Aman', color: 'green' };
              if ((value >= 15 && value < 20) || (value > 30 && value <= 40)) return { text: 'Waspada', color: 'yellow' };
              return { text: 'Berbahaya', color: 'red' };
            }
          };

          // Pastikan menggunakan nilai yang sudah dinormalisasi untuk broadcast
          const neckS = statusOf(neckDistance, 'neck');
          const backS = statusOf(backDistance, 'back');
          window.parent?.postMessage({
            type: 'SITSENSE_ULTRA_UPDATE',
            data: {
              neckDistance: neckDistance, // Sudah dinormalisasi di listener
              backDistance: backDistance, // Sudah dinormalisasi di listener
              signalStrength,
              neckStatus: neckS,
              backStatus: backS
            }
          }, '*');
        } catch (e) { }
      }, [neckDistance, backDistance, signalStrength]);

      // Update fungsi getStatusColor dan getStatus untuk konsistensi
      const getStatusColor = (distance, sensorType = 'back') => {
        const normalizeValue = (value, type) => {
          if (!Number.isFinite(value) || value <= 0) return null;
          if (value > 50) {
            const div10 = value / 10;
            const div100 = value / 100;
            if (type === 'back') {
              if (div10 >= 3 && div10 <= 25) return div10;
              if (div100 >= 3 && div100 <= 25) return div100;
            } else {
              if (div10 >= 15 && div10 <= 40) return div10;
              if (div100 >= 15 && div100 <= 40) return div100;
            }
            return null;
          }
          return value;
        };

        const normalized = normalizeValue(distance, sensorType);
        const value = normalized || distance;

        if (!Number.isFinite(value) || value <= 0 || value > 50) return 'text-red-500 bg-red-500/10 border-red-500/30';

        if (sensorType === 'back') {
          if (value >= 5 && value <= 15) return 'text-green-500 bg-green-500/10 border-green-500/30';
          if ((value >= 3 && value < 5) || (value > 15 && value <= 25)) return 'text-yellow-500 bg-yellow-500/10 border-yellow-500/30';
          return 'text-red-500 bg-red-500/10 border-red-500/30';
        } else {
          if (value >= 20 && value <= 30) return 'text-green-500 bg-green-500/10 border-green-500/30';
          if ((value >= 15 && value < 20) || (value > 30 && value <= 40)) return 'text-yellow-500 bg-yellow-500/10 border-yellow-500/30';
          return 'text-red-500 bg-red-500/10 border-red-500/30';
        }
      };

      const getStatus = (distance, sensorType = 'back') => {
        const normalizeValue = (value, type) => {
          if (!Number.isFinite(value) || value <= 0) return null;
          if (value > 50) {
            const div10 = value / 10;
            const div100 = value / 100;
            if (type === 'back') {
              if (div10 >= 3 && div10 <= 25) return div10;
              if (div100 >= 3 && div100 <= 25) return div100;
            } else {
              if (div10 >= 15 && div10 <= 40) return div10;
              if (div100 >= 15 && div100 <= 40) return div100;
            }
            return null;
          }
          return value;
        };

        const normalized = normalizeValue(distance, sensorType);
        const value = normalized || distance;

        if (!Number.isFinite(value) || value <= 0 || value > 50) {
          return value > 50 ? 'Error Sensor' : 'Menunggu Data';
        }

        if (sensorType === 'back') {
          if (value <= 0) return 'Terputus';
          if (value >= 5 && value <= 15) return 'Normal';
          if ((value >= 3 && value < 5) || (value > 15 && value <= 25)) return 'Perhatian';
          return 'Terlalu Dekat/Jauh';
        } else {
          if (value <= 0) return 'Terputus';
          if (value >= 20 && value <= 30) return 'Normal';
          if ((value >= 15 && value < 20) || (value > 30 && value <= 40)) return 'Perhatian';
          return 'Terlalu Dekat/Jauh';
        }
      };

      const SensorCard = ({ title, distance, gradient, accentColor, history, sensorType }) => {
        // Normalisasi nilai untuk ditampilkan
        const normalizeValue = (value, type) => {
          if (!Number.isFinite(value) || value <= 0) return null;
          if (value > 50) {
            const div10 = value / 10;
            const div100 = value / 100;
            if (type === 'back') {
              if (div10 >= 3 && div10 <= 25) return div10;
              if (div100 >= 3 && div100 <= 25) return div100;
            } else {
              if (div10 >= 15 && div10 <= 40) return div10;
              if (div100 >= 15 && div100 <= 40) return div100;
            }
            return null;
          }
          return value;
        };

        // Normalisasi nilai utama
        const normalizedDistance = normalizeValue(distance, sensorType);
        const displayDistance = (normalizedDistance !== null && Number.isFinite(normalizedDistance) && normalizedDistance > 0)
          ? normalizedDistance
          : (Number.isFinite(distance) && distance > 0 ? distance : 0);

        // Normalisasi history untuk grafik
        const normalizedHistory = history.map(val => {
          const normalized = normalizeValue(val, sensorType);
          return (normalized !== null && Number.isFinite(normalized) && normalized > 0) ? normalized : val;
        });

        // Gunakan displayDistance untuk status agar konsisten dengan tampilan
        const statusColor = getStatusColor(displayDistance, sensorType);
        const maxValue = 50;
        return (
          <div className="relative overflow-hidden rounded-3xl bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 border border-slate-700 shadow-2xl group hover:scale-[1.02] transition-all duration-500">
            <div className={`absolute inset-0 bg-gradient-to-br ${gradient} opacity-10 group-hover:opacity-20 transition-opacity duration-500`}></div>
            {particles.slice(0, 10).map(particle => (
              <div
                key={particle.id}
                className={`absolute rounded-full opacity-30`}
                style={{
                  left: `${particle.x}%`,
                  top: `${particle.y}%`,
                  width: `${particle.size}px`,
                  height: `${particle.size}px`,
                  backgroundColor: accentColor.includes('blue') ? '#60a5fa' : '#a78bfa',
                  animation: `float ${particle.duration}s ease-in-out infinite`,
                  animationDelay: `${particle.delay}s`
                }}
              ></div>
            ))}
            <div className="absolute inset-0 bg-[radial-gradient(circle_at_50%_120%,rgba(120,119,198,0.1),rgba(255,255,255,0))]"></div>
            <div className="absolute inset-0 opacity-20">
              <div className="absolute w-full h-0.5 bg-gradient-to-r from-transparent via-blue-500 to-transparent animate-scan"></div>
            </div>
            <div className={`absolute top-0 left-0 w-20 h-20 opacity-20 blur-2xl group-hover:opacity-40 transition-opacity`} style={{ backgroundColor: accentColor.includes('blue') ? '#60a5fa' : '#a78bfa' }}></div>
            <div className={`absolute bottom-0 right-0 w-20 h-20 opacity-20 blur-2xl group-hover:opacity-40 transition-opacity`} style={{ backgroundColor: accentColor.includes('blue') ? '#60a5fa' : '#a78bfa' }}></div>
            <div className="relative p-5">
              <div className="flex items-center justify-between mb-6">
                <div className="flex items-center gap-3">
                  <div className={`p-3 rounded-xl bg-gradient-to-br ${gradient} border shadow-lg relative overflow-hidden`} style={{ borderColor: accentColor.includes('blue') ? '#60a5fa' : '#a78bfa' }}>
                    <div className="absolute inset-0 bg-white opacity-0 group-hover:opacity-20 transition-opacity"></div>
                    <IconStatic name="activity" className="w-6 h-6 bg-gradient-to-r from-slate-400 to-slate-200" />
                  </div>
                  <div>
                    <h2 className="text-2xl font-bold text-white flex items-center gap-2">
                      {title}
                      <div className="relative">
                        <IconStatic name="zap" className={`w-5 h-5 bg-gradient-to-r ${gradient}`} />
                      </div>
                    </h2>
                    <p className="text-slate-400 text-sm flex items-center gap-1.5">
                      <IconStatic name="radio" className={`w-4 h-4 bg-gradient-to-r ${gradient}`} />
                      Sensor Ultrasonik
                    </p>
                  </div>
                </div>
                <div className="flex flex-col items-end gap-2">
                  <div className="flex items-center gap-2 px-3 py-1.5 rounded-full bg-green-500/20 border border-green-500/30 backdrop-blur-sm">
                    <div className="w-2 h-2 rounded-full bg-green-500 animate-pulse"></div>
                    <span className="text-green-400 text-xs font-semibold">AKTIF</span>
                  </div>
                  <div className="flex items-center gap-1.5 px-3 py-1 rounded-full bg-slate-800/50 border border-slate-700 backdrop-blur-sm">
                    <IconStatic name="activity" className="w-4 h-4 bg-gradient-to-r from-slate-400 to-slate-200" />
                    <span className="text-slate-300 text-xs">{signalStrength}%</span>
                  </div>
                </div>
              </div>
              <div className="relative mb-5 rounded-2xl overflow-hidden bg-gradient-to-br from-slate-800 via-slate-900 to-slate-800 border border-slate-700 p-5 h-48 flex items-center justify-center">
                <div className="absolute inset-0 bg-gradient-to-b from-transparent via-blue-500/10 to-transparent animate-scan-vertical"></div>
                <div className="absolute inset-0 flex items-center justify-center">
                  {[...Array(4)].map((_, i) => (
                    <div key={i} className="absolute rounded-full border-2 opacity-0 animate-sonar" style={{ borderColor: accentColor.includes('blue') ? '#60a5fa' : '#a78bfa', animationDelay: `${i * 0.6}s`, animationDuration: '2.4s', width: '32px', height: '32px' }}></div>
                  ))}
                </div>
                <div className="absolute inset-0 opacity-10">
                  <div className="w-full h-full" style={{
                    backgroundImage: 'linear-gradient(rgba(96, 165, 250, 0.3) 1px, transparent 1px), linear-gradient(90deg, rgba(96, 165, 250, 0.3) 1px, transparent 1px)',
                    backgroundSize: '20px 20px'
                  }}></div>
                </div>
                <div className="relative z-10 text-center">
                  <div className="relative w-28 h-28 mx-auto mb-4 rounded-2xl bg-gradient-to-br from-slate-700 to-slate-900 border-2 border-dashed border-slate-600 flex items-center justify-center shadow-2xl">
                    <div className="text-center relative z-10">
                      <IconStatic name="wifi" className={`w-6 h-6 bg-gradient-to-r ${gradient}`} />
                      <p className="text-slate-500 text-xs font-medium">Sensor aktif</p>
                    </div>
                  </div>
                  <div className="inline-flex items-center gap-2 px-3 py-1 rounded-full border" style={{ backgroundColor: accentColor.includes('blue') ? 'rgba(59,130,246,0.1)' : 'rgba(168,85,247,0.1)', borderColor: accentColor.includes('blue') ? 'rgba(59,130,246,0.3)' : 'rgba(168,85,247,0.3)' }}>
                    <div className="w-1.5 h-1.5 rounded-full bg-blue-400 animate-ping"></div>
                    <p className="text-slate-400 text-sm font-medium">Transmitting...</p>
                  </div>
                </div>
              </div>
              <div className="mb-4 relative">
                <div className="relative flex items-end justify-center gap-2 mb-4">
                  <IconStatic name="trending-up" className={`w-6 h-6 bg-gradient-to-r ${gradient}`} />
                  <span className="text-4xl font-bold bg-gradient-to-r bg-clip-text text-transparent drop-shadow-2xl animate-pulse" style={{ backgroundImage: accentColor.includes('blue') ? 'linear-gradient(to right, #3b82f6, #06b6d4)' : 'linear-gradient(to right, #a855f7, #ec4899)' }}>
                    {displayDistance > 0 ? displayDistance.toFixed(1) : '∞'}
                  </span>
                  <span className="text-xl font-semibold text-slate-400 mb-1.5">cm</span>
                </div>
                <div className="relative h-3.5 bg-slate-800 rounded-full overflow-hidden border border-slate-700 shadow-inner">
                  <div className="absolute top-0 left-0 h-full transition-all duration-300 rounded-full shadow-lg" style={{
                    width: `${Math.min((displayDistance / 50) * 100, 100)}%`,
                    backgroundImage: accentColor.includes('blue') ? 'linear-gradient(to right, #3b82f6, #06b6d4)' : 'linear-gradient(to right, #a855f7, #ec4899)'
                  }}>
                    <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/40 to-transparent animate-shimmer"></div>
                    <div className="absolute inset-0 bg-white/20 animate-pulse"></div>
                  </div>
                  {[25, 50, 75].map((mark) => (
                    <div key={mark} className="absolute top-0 h-full w-0.5 bg-slate-700" style={{ left: `${mark}%` }}></div>
                  ))}
                </div>
                <div className="flex justify-between mt-2 px-1">
                  <span className="text-xs text-slate-500">0cm</span>
                  <span className="text-xs text-slate-500">50cm</span>
                </div>
              </div>
              <div className={`flex items-center justify-center gap-2 px-3 py-2.5 rounded-xl border ${statusColor} backdrop-blur-sm relative overflow-hidden group/status`}>
                <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/5 to-transparent translate-x-[-100%] group-hover/status:translate-x-[100%] transition-transform duration-1000"></div>
                <IconStatic name="activity" className="w-5 h-5 bg-gradient-to-r from-slate-400 to-slate-200" />
                <span className="font-semibold text-lg">{getStatus(displayDistance, sensorType)}</span>
                <IconStatic name="alert-circle" className={`w-5 h-5 bg-gradient-to-r ${gradient}`} />
              </div>
              <div className="mt-5 grid grid-cols-3 gap-3">
                <div className="text-center p-2.5 rounded-xl bg-gradient-to-br from-slate-800 to-slate-900 border border-slate-700 hover:border-blue-500/50 transition-all duration-300 hover:shadow-lg hover:shadow-blue-500/20">
                  <p className="text-slate-400 text-xs mb-1.5">Min Range</p>
                  <p className="text-white font-bold text-lg">5 cm</p>
                </div>
                <div className="text-center p-2.5 rounded-xl bg-gradient-to-br from-slate-800 to-slate-900 border border-slate-700 hover:border-purple-500/50 transition-all duration-300 hover:shadow-lg hover:shadow-purple-500/20">
                  <p className="text-slate-400 text-xs mb-1.5">Max Range</p>
                  <p className="text-white font-bold text-lg">50 cm</p>
                </div>
                <div className="text-center p-2.5 rounded-xl bg-gradient-to-br from-slate-800 to-slate-900 border border-slate-700 hover:border-green-500/50 transition-all duration-300 hover:shadow-lg hover:shadow-green-500/20">
                  <p className="text-slate-400 text-xs mb-1.5">Akurasi</p>
                  <p className="text-white font-bold text-lg">±3mm</p>
                </div>
              </div>
              <div className="mt-5 relative">
                <div className="flex items-center justify-between mb-3">
                  <div className="flex items-center gap-2">
                    <IconStatic name="bar-chart-3" className={`w-5 h-5 bg-gradient-to-r ${gradient}`} />
                    <span className="text-slate-300 font-semibold text-sm">Real-time Graph</span>
                  </div>
                  <div className="flex items-center gap-2 px-2 py-1 rounded-lg bg-slate-800/50 border border-slate-700">
                    <div className="w-1.5 h-1.5 rounded-full bg-green-500 animate-pulse"></div>
                    <span className="text-slate-400 text-xs">Live</span>
                  </div>
                </div>
                <div className="relative h-28 bg-slate-900/50 rounded-xl border border-slate-700 p-3 overflow-hidden backdrop-blur-sm">
                  <div className="absolute inset-0 flex flex-col justify-between p-4 pointer-events-none">
                    {[0, 1, 2, 3, 4].map((i) => (<div key={i} className="w-full h-px bg-slate-700/30"></div>))}
                  </div>
                  <svg className="w-full h-full" preserveAspectRatio="none" viewBox="0 0 100 100">
                    <defs>
                      <linearGradient id={`gradient-${title}`} x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" stopColor={accentColor.includes('blue') ? '#3b82f6' : '#a855f7'} stopOpacity="0.5" />
                        <stop offset="100%" stopColor={accentColor.includes('blue') ? '#3b82f6' : '#a855f7'} stopOpacity="0.05" />
                      </linearGradient>
                    </defs>
                    <path
                      d={`M 0 ${100 - (normalizedHistory[0] / maxValue) * 100} ${normalizedHistory.map((val, i) =>
                        `L ${(i / (normalizedHistory.length - 1)) * 100} ${100 - (val / maxValue) * 100}`
                      ).join(' ')} L 100 100 L 0 100 Z`}
                      fill={`url(#gradient-${title})`}
                      vectorEffect="non-scaling-stroke"
                    />
                    <path
                      d={`M 0 ${100 - (normalizedHistory[0] / maxValue) * 100} ${normalizedHistory.map((val, i) =>
                        `L ${(i / (normalizedHistory.length - 1)) * 100} ${100 - (val / maxValue) * 100}`
                      ).join(' ')}`}
                      fill="none"
                      stroke={accentColor.includes('blue') ? '#3b82f6' : '#a855f7'}
                      strokeWidth="2"
                      vectorEffect="non-scaling-stroke"
                    />
                    <path
                      d={`M 0 ${100 - (normalizedHistory[0] / maxValue) * 100} ${normalizedHistory.map((val, i) =>
                        `L ${(i / (normalizedHistory.length - 1)) * 100} ${100 - (val / maxValue) * 100}`
                      ).join(' ')}`}
                      fill="none"
                      stroke={accentColor.includes('blue') ? '#3b82f6' : '#a855f7'}
                      strokeWidth="4"
                      vectorEffect="non-scaling-stroke"
                      opacity="0.3"
                    />
                    <circle cx="100" cy={100 - (normalizedHistory[normalizedHistory.length - 1] / maxValue) * 100} r="3" fill={accentColor.includes('blue') ? '#3b82f6' : '#a855f7'}>
                      <animate attributeName="r" values="3;5;3" dur="1.5s" repeatCount="indefinite" />
                    </circle>
                  </svg>
                  <div className="absolute left-1 top-2 text-xs text-slate-500">50cm</div>
                  <div className="absolute left-1 bottom-2 text-xs text-slate-500">0cm</div>
                </div>
                <div className="mt-2.5 grid grid-cols-3 gap-2">
                  <div className="text-center p-2 rounded-lg bg-slate-800/30 border border-slate-700/50">
                    <p className="text-slate-500 text-xs">Avg</p>
                    <p className="font-bold text-sm" style={{ color: accentColor.includes('blue') ? '#60a5fa' : '#a78bfa' }}>
                      {(normalizedHistory.reduce((a, b) => a + b, 0) / normalizedHistory.length).toFixed(1)}cm
                    </p>
                  </div>
                  <div className="text-center p-2 rounded-lg bg-slate-800/30 border border-slate-700/50">
                    <p className="text-slate-500 text-xs">Min</p>
                    <p className="font-bold text-sm" style={{ color: accentColor.includes('blue') ? '#60a5fa' : '#a78bfa' }}>
                      {Math.min(...normalizedHistory).toFixed(1)}cm
                    </p>
                  </div>
                  <div className="text-center p-2 rounded-lg bg-slate-800/30 border border-slate-700/50">
                    <p className="text-slate-500 text-xs">Max</p>
                    <p className="font-bold text-sm" style={{ color: accentColor.includes('blue') ? '#60a5fa' : '#a78bfa' }}>
                      {Math.max(...normalizedHistory).toFixed(1)}cm
                    </p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        );
      };

      // Render lucide icons after each render
      useEffect(() => {
        try { window.lucide?.createIcons?.(); } catch (e) { }
      }, []); // hanya running sekali


      return (
        <div className="min-h-[700px] bg-transparent p-4">
          <div className="max-w-5xl mx-auto grid md:grid-cols-2 gap-6">
            <SensorCard title="Sensor Leher" distance={neckDistance} gradient="from-blue-500 to-cyan-500" accentColor="blue" history={neckHistory} sensorType="neck" />
            <SensorCard title="Sensor Punggung" distance={backDistance} gradient="from-purple-500 to-pink-500" accentColor="purple" history={backHistory} sensorType="back" />
          </div>
          {/* Debug Console */}
          <div className="fixed bottom-4 right-4 z-[1000]">
            <div className="flex justify-end mb-2">
              <button onClick={() => setDebugVisible(v => !v)} className="px-3 py-1.5 rounded-lg text-xs font-semibold border border-slate-700 bg-slate-900/80 text-slate-200 shadow hover:bg-slate-800">
                {debugVisible ? 'Sembunyikan Debug' : 'Tampilkan Debug'}
              </button>
            </div>
            {debugVisible && (
              <div className="w-[min(380px,90vw)] max-h-[40vh] overflow-auto rounded-xl border border-slate-700 bg-slate-900/80 backdrop-blur p-3 shadow-2xl">
                <div className="text-xs text-slate-400 mb-2">
                  Debug Data (realtime) — tekan tombol di atas untuk toggle. Tambahkan ?debug=1 pada URL untuk default menyala.
                </div>
                <div className="text-[11px] font-mono space-y-1">
                  <div className="text-slate-300">Neck: {neckDistance.toFixed(2)} cm • Back: {backDistance.toFixed(2)} cm • Signal: {signalStrength}%</div>
                  <hr className="border-slate-700 my-2" />
                  {events.length === 0 && <div className="text-slate-500">Belum ada data.</div>}
                  {events.slice().reverse().map((e, i) => (
                    <div key={i} className="text-slate-300">
                      [{e.ts}] {e.sensor}@{e.path} → {typeof e.parsed === 'number' ? e.parsed : 'NaN'}
                      <div className="text-slate-500 break-words">raw: {typeof e.raw === 'object' ? JSON.stringify(e.raw) : String(e.raw)}</div>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<UltrasonicMonitor />);
    // Initial icon upgrade
  </script>
</body>

</html>